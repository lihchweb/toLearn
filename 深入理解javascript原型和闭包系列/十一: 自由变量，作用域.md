
> 在A作用域中使用的变量X，却没有在A作用域内声明（它是在其他作用域声明的），那么对于A作用域来说，X就是一个自由变量。


```js
var x = 10;

function foo() {
  var b = 20;
  console.log(x + b);
}

//对于foo作用域来说，x就是一个自由变量
```

**静态作用域: 自由变量的值要到创建该函数的那个作用域去取。**

如下demo:

```js
var x = 10;

function fn() {
  console.log(x)
}

function show(f) {
  var x = 20;
  
  (function(){
    f();
  })()
}

show(fn) //打印出10，而不是20
```

**作用域链: 在查找变量的时候，如果在当前作用域没找到，就去其父作用域去找，直到找到全局作用域，如果在全局作用域内仍找不到，那就真的没有了。我们跨的这个链，可以理解为作用域链**

简单总结取自由变量a时，作用域链的过程:

1. 先在当前作用域查找a,如果有，获取并结束，如果没有，继续查找
2. 如果当前作用域是全局作用域，且未找到a，那么表示a未定义，结束查找，否则继续查找
2. 如果当前作用域不是全局作用域，那么就将创建该函数的作用域作为当前作用域
4. 重复第一步操作

```js
var a = 10;

function fn() {
  var b = 20;
  
  function bar() {
    console.log(a + b);
  }
  
  return bar;
}

var res = fn(),
    b = 200;
    
res(); //30
```

res返回的是fn(), 而fn()返回bar，res()执行就相当于bar()执行。取b的值时，直接在fn的作用域下取，取a的值时，试图在fn作用域下取，但是取不到。

那就要到创建fn的那个作用域取查找，找到了10.

所以结果打印出30
