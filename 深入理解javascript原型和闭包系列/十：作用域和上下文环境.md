![image](https://user-images.githubusercontent.com/24636279/120753511-dad4fb00-c53d-11eb-9f27-3d16855cad9e.png)

**如上图所示，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义的时候就已经确定了，而不是在调用时确定。**

#### 第一步，在加载程序的时候，已经确定了全局上下文环境，并随着程序的执行进而对变量进行赋值。

![image](https://user-images.githubusercontent.com/24636279/120754093-c34a4200-c53e-11eb-8cc6-654a11964f71.png)

#### 第二步，程序执行到21行，调用fn(10),此时生成调用fn函数时的上下文环境，压栈，将此上下文设置为活动状态

![image](https://user-images.githubusercontent.com/24636279/120754508-5c795880-c53f-11eb-8f90-a17d27aff503.png)

#### 第三步，程序执行到17行时，调用bar()函数，此时生成调用bar函数的上下文环境，压栈，将此上下文色设置为活动状态

![image](https://user-images.githubusercontent.com/24636279/120755195-386a4700-c540-11eb-8f0d-026a455324b1.png)

#### 第四步，执行完第17行，bar(100)调用完成，接着执行18行，调用bar(200),则又生成bar(200)的上下文环境，压栈，设置此上下文为活动状态。

![image](https://user-images.githubusercontent.com/24636279/120755417-88490e00-c540-11eb-9a6e-4e3184d7a7ad.png)

#### 第五步，执行完18行，bar(200)调用结束，它的上下文环境销毁。回到了fn(10)的上下文环境，fn上下文环境被设置为活动状态

![image](https://user-images.githubusercontent.com/24636279/120755637-ce9e6d00-c540-11eb-93af-039b012f1695.png)

#### 第六步，执行完21行代码，fn(10)执行完毕，fn(10)的上下文执行环境被销毁，全局上下文环境又回到活动状态


![image](https://user-images.githubusercontent.com/24636279/120755749-f68dd080-c540-11eb-8e78-a889089097a2.png)


> 作用域好像一个’地盘‘，是个抽象的概念，其中没有变量。要通过作用域对应的上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的上下文环境，继而产生不同的变量的值。
> 所以，变量的值是在执行过程中确定的，而作用域却是在函数创建时就确定了


**如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。**
